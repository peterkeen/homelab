<%-
require 'uri'

stage_one = {
  listen: [
    ":80",
    ":443",
  ],
  automatic_https: {
    disable_certificates: true
  },
  logs: {},
  metrics: {
    per_host: true
  },
  trusted_proxies: {
    source: "static",
    ranges: hosts_file.hosts.values.map { |h| "#{h.local_ip}/32" } + ["10.0.0.0/8", "192.168.0.0/16", "172.16.0.0/12", "127.0.0.0/8"]
  },
  routes: []
}

stage_two = {
  listen: [
    ":8888"
  ],
  automatic_https: {
    disable: true
  },
  logs: {},
  metrics: {
    per_host: true
  },
  trusted_proxies: {
    source: "static",
    ranges: hosts_file.hosts.values.map { |h| "#{h.local_ip}/32" } + ["10.0.0.0/8", "192.168.0.0/16", "172.16.0.0/12", "127.0.0.0/8"]
  }, 
  routes: []
}

all_web_configs do |host, stack, service, web_conf|
  next unless host == this_host || web_conf[:public_ingress]

  web_conf[:routes].each do |route|
    if route[:redirect] != nil
      stage_one[:routes] << {
        match: [
          {
            host: [web_conf[:fqdn]],
          },
        ],
        handle: [
          {
            handler: "static_response",
            status_code: 302,
            headers: {
              "Location": [route[:redirect]]
            }
          }
        ]
      }
      next
    end

    stage_one_upstream = "localhost:8888"
    if web_conf[:anubis] && this_host.has_stack?("anubis")
      stage_one_upstream = "anubis:8923"
    end

    stage_one[:routes] << {
      match: [
        {
          host: [web_conf[:fqdn]],
          path: ["#{route[:path]}*"]
        }
      ],
      handle: [
        {
          handler: "reverse_proxy",
          upstreams: [
            { dial: stage_one_upstream }
          ],
          headers: {
            request: {
              add: {
                "X-Real-IP": ["{http.request.remote.host}"],
                "X-Http-Version": ["1.1"]
              }
            }
          }
        }
      ]
    }

    upstream = host == this_host ? URI(route[:upstream]) : URI("https://#{host.local_ip}:443")

    stage_two_handler = {
      handler: "reverse_proxy",
      transport: {
        protocol: "http",
        resolver: {
          addresses: ["127.0.0.11"]
        }
      },
      upstreams: [
        { dial: "#{upstream.hostname}:#{upstream.port}" }
      ]
    }

    if upstream.scheme == "https"
      stage_two_handler[:transport][:tls] = {
        server_name: web_conf[:fqdn]
      }
      if web_conf[:insecure_skip_verify]
        stage_two_handler[:transport][:tls][:insecure_skip_verify] = true
      end
    end

    stage_two[:routes] << {
      match: [
        {
          host: [web_conf[:fqdn]],
          path: ["#{route[:path]}*"]
        }
      ],
      handle: [ stage_two_handler ]
    }
  end

  web_conf[:alternate_hostnames].each do |hostname|
    stage_one[:routes] << {
      match: [
        {
          host: [hostname],
        },
      ],
      handle: [
        {
          handler: "static_response",
          status_code: 302,
          headers: {
            "Location": [
              "https://#{web_conf[:fqdn]}"
            ]
          }
        }
      ]
    }
  end
end

certificates = all_host_certs.keys.map do |certname|
  {
    certificate: "/etc/letsencrypt/certificates/#{certname}.crt",
    key: "/etc/letsencrypt/certificates/#{certname}.key"
  }
end

@config = {
  admin: {
    listen: ":2019"
  },
  apps: {
    http: {
      servers: {
        stage_one: stage_one,
        stage_two: stage_two
      }
    },
    tls: {
      certificates: {
        load_files: certificates
      }
    },
    cache: {
      default_cache_control: "no-store"
    }
  }
}
-%>
<%= JSON.pretty_generate(@config) %>
